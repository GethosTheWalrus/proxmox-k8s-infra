stages:
  - build
  - deploy
  - test
  - destroy

deploy-cluster:
  stage: build
  image: 
    name: hashicorp/terraform:latest
    entrypoint: [""]
  before_script:
    - export TF_VAR_username=$(echo "$PVEUSER" | base64 -d)
    - export TF_VAR_password=$(echo "$PVEPASSWORD" | base64 -d)
    - export PROJECT_ID=5
    - export TF_USERNAME=$(echo "$GITLABUSERNAME" | base64 -d)
    - export TF_PASSWORD=$(echo "$GITLABACCESSTOKEN" | base64 -d)
    - export TF_ADDRESS="http://git.home/api/v4/projects/$PROJECT_ID/terraform/state/proxmox-k8s-infra"
    - terraform init -backend-config=address=${TF_ADDRESS} -backend-config=lock_address=${TF_ADDRESS}/lock -backend-config=unlock_address=${TF_ADDRESS}/lock -backend-config=username=${TF_USERNAME} -backend-config=password=${TF_PASSWORD} -backend-config=lock_method=POST -backend-config=unlock_method=DELETE -backend-config=retry_wait_min=5
  script:
    - terraform apply -parallelism=2 --auto-approve=true
    - terraform output vm_private_key > key
    - terraform output vm_public_key > key.pub
    - sed -i '1d;$d' key
    - chmod 600 key
    - cat key
  rules:
  - if: '$CI_COMMIT_BRANCH == "main"'
  artifacts:
    paths:
      - scripts
      - key
      - storage-class.yaml


init-master:
  stage: build
  image:
    name: ubuntu:latest
  variables:
    K8S1: 192.168.69.80
    ROLE: master
    TOKEN: abcdef.0123456789abcdef
  before_script:
    - apt update && apt install -y openssh-client
  script:
  - ssh -i key -o StrictHostKeyChecking=no k8s@"$K8S1" "sudo ROLE=$ROLE TOKEN=$TOKEN bash -s" < scripts/install-k8s.sh
  - scp -i key -o StrictHostKeyChecking=no k8s@"$K8S1":~/hash $CI_PROJECT_DIR/hash
  rules:
  - if: $CI_COMMIT_TITLE =~ /-init$/
    when: always
  allow_failure: false
  needs:
    - deploy-cluster
  artifacts:
    paths:
      - hash
      - key
      - scripts


init-workers:
  stage: build
  image:
    name: ubuntu:latest
  variables:
    K8S1: 192.168.69.80
    K8S2: 192.168.69.81
    K8S3: 192.168.69.82
    K8S4: 192.168.69.83
    JOINTOKEN: abcdef.0123456789abcdef
    ROLE: worker
  before_script:
    - apt update && apt install -y openssh-client
  script:
    - scp -i key -o StrictHostKeyChecking=no k8s@"$K8S1":~/hash $CI_PROJECT_DIR/hash
    - ssh -i key -o StrictHostKeyChecking=no k8s@"$K8S2" "sudo ROLE=$ROLE bash -s" < $CI_PROJECT_DIR/scripts/install-k8s.sh $K8S1 $JOINTOKEN $(cat $CI_PROJECT_DIR/hash)
    - ssh -i key -o StrictHostKeyChecking=no k8s@"$K8S3" "sudo ROLE=$ROLE bash -s" < $CI_PROJECT_DIR/scripts/install-k8s.sh $K8S1 $JOINTOKEN $(cat $CI_PROJECT_DIR/hash)
    - ssh -i key -o StrictHostKeyChecking=no k8s@"$K8S4" "sudo ROLE=$ROLE bash -s" < $CI_PROJECT_DIR/scripts/install-k8s.sh $K8S1 $JOINTOKEN $(cat $CI_PROJECT_DIR/hash)
  rules:
  - if: $CI_COMMIT_TITLE =~ /-init$/
    when: always
    allow_failure: false
  needs:
    - deploy-cluster
    - init-master


deploy-metallb:
  stage: deploy
  image:
    name: alpine/k8s:1.29.13
  variables:
    K8S1: 192.168.69.80
    METALLB_NAMESPACE: metallb-system
    IP_ADDRESS_RANGE: 192.168.69.95-192.168.69.100
  before_script:
    - apk --no-cache add openssh-client kubectl helm
  script:
    - mkdir ~/.kube
    - scp -i key -o StrictHostKeyChecking=no k8s@"$K8S1":~/.kube/config ~/.kube/config
    - export KUBECONFIG=~/.kube/config
    - chmod +x scripts/install-metallb.sh
    - scripts/install-metallb.sh
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_TITLE =~ /-init$/'
      when: always
    - when: manual
  dependencies:
    - init-master
    - init-workers


deploy-nginx:
  stage: deploy
  image:
    name: alpine/k8s:1.29.13
  variables:
    K8S1: 192.168.69.80
  before_script:
    - apk --no-cache add openssh-client
  script:
    - mkdir ~/.kube
    - scp -i key -o StrictHostKeyChecking=no k8s@"$K8S1":~/.kube/config ~/.kube/config
    - export KUBECONFIG=~/.kube/config
    - kubectl create deploy nginx --image nginx
    - kubectl expose deploy nginx --port 80 --type LoadBalancer
  rules:
  - when: always
  allow_failure: false
  needs:
    - init-master
    - init-workers
    - deploy-metallb


deploy-openebs:
  stage: deploy
  image:
    name: alpine/k8s:1.29.13
  variables:
    K8S1: 192.168.69.80
  before_script:
    - apk --no-cache add openssh-client kubectl helm
  script:
    - mkdir ~/.kube
    - scp -i key -o StrictHostKeyChecking=no k8s@"$K8S1":~/.kube/config ~/.kube/config
    - export KUBECONFIG=~/.kube/config
    - chmod +x scripts/install-openebs.sh
    - scripts/install-openebs.sh
    - echo "Applying storage class..."
    - kubectl apply -f storage-class.yaml
    - echo "Verifying storage class..."
    - kubectl get sc
    - echo "Verifying OpenEBS pods are running..."
    - kubectl get pods -n openebs
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_TITLE =~ /-init$/'
      when: always
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
  needs:
    - init-master
    - init-workers
    - deploy-metallb
  timeout: 15m


deploy-temporal:
    stage: deploy
    image:
      name: alpine/k8s:1.29.13
    variables:
      K8S1: 192.168.69.80
      LOAD_BALANCER_IP: 192.168.69.98
    before_script:
      - apk --no-cache add openssh-client kubectl helm
    script:
      - mkdir ~/.kube
      - scp -i key -o StrictHostKeyChecking=no k8s@"$K8S1":~/.kube/config ~/.kube/config
      - export KUBECONFIG=~/.kube/config
      - chmod +x scripts/install-temporal.sh
      - scripts/install-temporal.sh
    rules:
      - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_TITLE =~ /-init$/'
        when: always
      - if: '$CI_COMMIT_BRANCH == "main"'
        when: manual
    needs:
    - init-master
    - init-workers
    - deploy-metallb
    - deploy-openebs


deploy-temporal-workers:
  stage: deploy
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_DRIVER: overlay2
  before_script:
    - apk add --no-cache curl
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl
    - mv kubectl /usr/local/bin/
    - echo "$KUBE_CONFIG" | base64 -d > kubeconfig.yaml
    - export KUBECONFIG=kubeconfig.yaml
    # Configure Docker to use insecure registry
    - mkdir -p /etc/docker
    - echo '{"insecure-registries": ["git.home:5050"]}' > /etc/docker/daemon.json
    - docker info
  script:
    # Build and push Python worker
    - docker build -t ${CI_REGISTRY}/temporal/python-worker:${CI_COMMIT_SHA} workers/python
    - docker push ${CI_REGISTRY}/temporal/python-worker:${CI_COMMIT_SHA}
    - sed "s|\${REGISTRY}|${CI_REGISTRY}/temporal|g" workers/k8s/python-worker.yaml | kubectl apply -f -

    # Build and push TypeScript worker
    - docker build -t ${CI_REGISTRY}/temporal/typescript-worker:${CI_COMMIT_SHA} workers/typescript
    - docker push ${CI_REGISTRY}/temporal/typescript-worker:${CI_COMMIT_SHA}
    - sed "s|\${REGISTRY}|${CI_REGISTRY}/temporal|g" workers/k8s/typescript-worker.yaml | kubectl apply -f -

    # Build and push C# worker
    - docker build -t ${CI_REGISTRY}/temporal/csharp-worker:${CI_COMMIT_SHA} workers/csharp
    - docker push ${CI_REGISTRY}/temporal/csharp-worker:${CI_COMMIT_SHA}
    - sed "s|\${REGISTRY}|${CI_REGISTRY}/temporal|g" workers/k8s/csharp-worker.yaml | kubectl apply -f -

    # Build and push Go worker
    - docker build -t ${CI_REGISTRY}/temporal/go-worker:${CI_COMMIT_SHA} workers/go
    - docker push ${CI_REGISTRY}/temporal/go-worker:${CI_COMMIT_SHA}
    - sed "s|\${REGISTRY}|${CI_REGISTRY}/temporal|g" workers/k8s/go-worker.yaml | kubectl apply -f -

    # Wait for all workers to be ready
    - kubectl rollout status deployment/python-worker -n temporal
    - kubectl rollout status deployment/typescript-worker -n temporal
    - kubectl rollout status deployment/csharp-worker -n temporal
    - kubectl rollout status deployment/go-worker -n temporal
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - when: manual
  environment:
    name: production
  needs:
    - init-master
    - init-workers
    - deploy-metallb
    - deploy-openebs
    - deploy-temporal

test-temporal-workflow:
  stage: test
  image: python:3.11-slim
  variables:
    K8S1: 192.168.69.80
  before_script:
    - apt-get update && apt-get install -y openssh-client
    - pip install temporalio python-dotenv
    - mkdir ~/.kube
    - scp -i key -o StrictHostKeyChecking=no k8s@"$K8S1":~/.kube/config ~/.kube/config
    - export KUBECONFIG=~/.kube/config
  script:
    # Wait for all workers to be ready
    - echo "Waiting for workers to be ready..."
    - kubectl rollout status deployment/python-worker -n temporal
    - kubectl rollout status deployment/typescript-worker -n temporal
    - kubectl rollout status deployment/csharp-worker -n temporal
    - kubectl rollout status deployment/go-worker -n temporal

    # Run the workflow test
    - echo "Running workflow test..."
    - cd workers/python
    - python test_workflow.py > workflow_output.txt

    # Verify the output contains results from all languages
    - |
      if ! grep -q "Python says:" workflow_output.txt; then
        echo "Python worker result not found"
        exit 1
      fi
      if ! grep -q "TypeScript says:" workflow_output.txt; then
        echo "TypeScript worker result not found"
        exit 1
      fi
      if ! grep -q "C# says:" workflow_output.txt; then
        echo "C# worker result not found"
        exit 1
      fi
      if ! grep -q "Go says:" workflow_output.txt; then
        echo "Go worker result not found"
        exit 1
      fi

    # Display the workflow output
    - echo "Workflow output:"
    - cat workflow_output.txt
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - when: manual
  environment:
    name: production
  needs:
    - deploy-temporal
    - deploy-temporal-workers


destroy-cluster:
  stage: destroy
  image: 
    name: hashicorp/terraform:latest
    entrypoint: [""]
  before_script:
    - export TF_VAR_username=$(echo "$PVEUSER" | base64 -d)
    - export TF_VAR_password=$(echo "$PVEPASSWORD" | base64 -d)
    - export PROJECT_ID=5
    - export TF_USERNAME=$(echo "$GITLABUSERNAME" | base64 -d)
    - export TF_PASSWORD=$(echo "$GITLABACCESSTOKEN" | base64 -d)
    - export TF_ADDRESS="http://git.home/api/v4/projects/$PROJECT_ID/terraform/state/proxmox-k8s-infra"
    - terraform init -backend-config=address=${TF_ADDRESS} -backend-config=lock_address=${TF_ADDRESS}/lock -backend-config=unlock_address=${TF_ADDRESS}/lock -backend-config=username=${TF_USERNAME} -backend-config=password=${TF_PASSWORD} -backend-config=lock_method=POST -backend-config=unlock_method=DELETE -backend-config=retry_wait_min=5
  script:
    - terraform destroy --auto-approve=true
  allow_failure: true
  rules:
  - when: manual
  needs: []